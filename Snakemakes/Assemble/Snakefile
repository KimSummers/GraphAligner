configfile: "config.yaml"
ALIGNERBINDIR = config["GraphAlignerBinDirectory"]
ALIGNERSCRIPTDIR = config["GraphAlignerScriptDirectory"]
VGPATH = config["VGPath"]
BCALMPATH = config["BcalmPath"]
BCALMCONVERTPATH = config["BcalmConvertPath"]
LIGHTERPATH = config["LighterPath"]
GENOMESIZE = config["GenomeSize"]
SHORTREADCOVERAGE = config["ShortreadCoverage"]
TMPDIR = config["TempDirectory"]
OUTDIR = config["OutputDirectory"]
SHORTREADDIR = config["ShortReadDirectory"]
SHORTREADS = config["ShortReads"]
LONGREADDIR = config["LongReadDirectory"]
LONGREADS = config["LongReads"]
SMALLK = config["SmallK"]
BIGK = config["BigK"]
ABUNDANCE = config["Abundance"]
MAXOVERLAPCOUNT = config["MaxOverlapCount"]
MINOVERLAPLENGTH = config["MinOverlapLength"]
MINOVERLAPIDENTITY = config["MinOverlapIdentity"]

SHORTREADNAMES = [n.split('.')[0] for n in SHORTREADS]
SHORTREADEXTENSIONS = ['.'.join(n.split('.')[1:]) for n in SHORTREADS]

rule all:
	input:
		OUTDIR + "assembly_withchains.gfa",
		OUTDIR + "chains.gfa"

rule correct_short_reads:
	input:
		expand(SHORTREADDIR + "{name}.{ext}", zip, name=SHORTREADNAMES, ext=SHORTREADEXTENSIONS)
	output:
		temp(expand(TMPDIR + "{name}.cor.{ext}", zip, name=SHORTREADNAMES, ext=SHORTREADEXTENSIONS))
	params:
		files = lambda wildcards, input: ' '.join(["-r " + name for name in input]),
		alpha = 7.0 / SHORTREADCOVERAGE
	threads: 40
	log:
		stdout = TMPDIR + "lighter_stdout.txt",
		stderr = TMPDIR + "lighter_stderr.txt"
	shell:
		"/usr/bin/time -v {LIGHTERPATH} -od {TMPDIR} -t {threads} -k {SMALLK} {GENOMESIZE} {params.alpha} {params.files} 1> {log.stdout} 2> {log.stderr}"

rule read_names:
	input: rules.correct_short_reads.output
	output: temp("filenames")
	shell: "ls -1 {input} > {output}"

rule run_bcalm:
	input: 
		name = "filenames",
		files = rules.correct_short_reads.output
	output: temp("filenames.unitigs.fa")
	shadow: "full"
	log:
		stdout = TMPDIR + "bcalm_stdout.txt",
		stderr = TMPDIR + "bcalm_stderr.txt"
	threads: 40
	shell: "/usr/bin/time -v {BCALMPATH} -nb-cores {threads} -in {input.name} -kmer-size {BIGK} -abundance-min {ABUNDANCE} > {log.stdout} 2> {log.stderr}"

rule convert_bcalm:
	input: rules.run_bcalm.output
	output: temp(TMPDIR + "graph-tip.gfa")
	shell: "{BCALMCONVERTPATH} {input} {output} {BIGK}"

rule split_graph:
	input: rules.convert_bcalm.output
	output: TMPDIR + "graph.gfa"
	shell:  "{ALIGNERBINDIR}SplitGraph {input} 150 {output}"

rule align_reads:
	input:
		graph = TMPDIR + "graph.gfa",
		reads = expand(LONGREADDIR + "{name}", name=LONGREADS)
	params:
		readconcat = lambda wildcards, input: ' '.join(input.reads)
	output:
		TMPDIR + "alns.gam"
	log:
		stdout = TMPDIR + "aligner_stdout.txt",
		stderr = TMPDIR + "aligner_stderr.txt"
	threads: 40
	shell:
		"/usr/bin/time -v {ALIGNERBINDIR}GraphAligner -g {input.graph} -a {output} -f {params.readconcat} -t {threads} 1> {log.stdout} 2> {log.stderr}"

rule initial_assembly:
	input:
		graph = TMPDIR + "graph.gfa",
		alignments = rules.align_reads.output
	output:
		assembly = temp(TMPDIR + "assembly.gfa")
	threads: 40
	log:
		stdout = TMPDIR + "assemble_stdout.txt",
		stderr = TMPDIR + "assemble_stderr.txt"
	shell:
		"/usr/bin/time -v {ALIGNERBINDIR}AssembleByAlignment {input.graph} {input.alignments} {output} {MINOVERLAPLENGTH} {MINOVERLAPIDENTITY} {MAXOVERLAPCOUNT} {threads} 1> {log.stdout} 2> {log.stderr}"

rule unitigify_1:
	input: rules.initial_assembly.output
	output: temp(TMPDIR + "assembly-unitig.gfa")
	shell: "{ALIGNERSCRIPTDIR}unitigify_assembly.py {input} {output}"

rule untip:
	input: rules.unitigify_1.output
	output: temp(TMPDIR + "assembly-unitig-untip.gfa")
	shell: "{ALIGNERBINDIR}UntipRelative 500 2000 0.01 < {input} > {output}"

rule unitigify_2:
	input: rules.untip.output
	output: temp(TMPDIR + "assembly-unitig-untip-unitig.gfa")
	shell: "{ALIGNERSCRIPTDIR}unitigify_assembly.py {input} {output}"

rule resolve_short_repeats:
	input: rules.unitigify_2.output
	output: temp(TMPDIR + "assembly-unitigs-untip-unitig-repeat.gfa")
	shell: "{ALIGNERSCRIPTDIR}resolve_short_repeats.py {input} {output}"

rule unitigify_3:
	input: rules.resolve_short_repeats.output
	output: temp(TMPDIR + "assembly-unitigs-untip-unitig-repeat-unitig.gfa")
	shell: "{ALIGNERSCRIPTDIR}unitigify_assembly.py {input} {output}"

rule topofy:
	input: rules.unitigify_3.output
	output: temp(TMPDIR + "topo.gfa")
	shell: "{ALIGNERSCRIPTDIR}filter_unconnected_nodes.py {input} {output}"

rule remove_overlap_and_vgfy:
	input: rules.topofy.output
	output: temp(TMPDIR + "topo.vg")
	shell: "sed 's/[0-9]\\+M/0M/g' < {input} | {VGPATH} view -Fv - > {output}"

rule snarls:
	input: rules.remove_overlap_and_vgfy.output
	output:
		snarls = temp(TMPDIR + "snarls.pb"),
		traversals = temp(TMPDIR + "traversals.travs")
	shell: "{VGPATH} snarls -r {output.traversals} -m 1000 {input} > {output.snarls}"

rule fix_traversals:
	input: rules.snarls.output.traversals
	output: temp(TMPDIR + "viewtraversals.json")
	shell: "{VGPATH} view -E {input} | sed 's/$/,/g' | sed '1 s/^/[/g' | sed '$ s/,$/]/g' > {output}"

rule make_chains:
	input:
		graph = rules.unitigify_3.output,
		traversals = rules.fix_traversals.output
	output:
		graph_withchains = OUTDIR + "assembly_withchains.gfa",
		chains = OUTDIR + "chains.gfa"
	shell: "{ALIGNERSCRIPTDIR}make_chain_graph.py {input.graph} {input.traversals} {output.graph_withchains} {output.chains}"
