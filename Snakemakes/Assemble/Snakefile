configfile: "config.yaml"
ALIGNERBINDIR = config["GraphAlignerBinDirectory"]
ALIGNERSCRIPTDIR = config["GraphAlignerScriptDirectory"]
VGPATH = config["VGPath"]
BCALMPATH = config["BcalmPath"]
BCALMCONVERTPATH = config["BcalmConvertPath"]
LIGHTERPATH = config["LighterPath"]
GENOMESIZE = config["GenomeSize"]
SHORTREADCOVERAGE = config["ShortreadCoverage"]
TMPDIR = config["TempDirectory"]
OUTDIR = config["OutputDirectory"]
SHORTREADDIR = config["ShortReadDirectory"]
SHORTREADS = config["ShortReads"]
LONGREADDIR = config["LongReadDirectory"]
LONGREADS = config["LongReads"]
SMALLK = config["SmallK"]
BIGK = config["BigK"]
ABUNDANCE = config["Abundance"]
MAXOVERLAPCOUNT = config["MaxOverlapCount"]
MINOVERLAPLENGTH = config["MinOverlapLength"]
MINOVERLAPIDENTITY = config["MinOverlapIdentity"]

SHORTREADNAMES = [n.split('.')[0] for n in SHORTREADS]
SHORTREADEXTENSIONS = ['.'.join(n.split('.')[1:]) for n in SHORTREADS]

wildcard_constraints:
	graph = "assembly((-unitig)|(-untip)|(-topo)|(-withchains)|(-repeat)|(-cycle))*"

rule all:
	input:
		OUTDIR + "assembly.gfa",
		OUTDIR + "chains.gfa",
		OUTDIR + "nodeinfo_assembly.csv",
		OUTDIR + "nodeinfo_chains.csv"

rule correct_short_reads:
	input:
		expand(SHORTREADDIR + "{name}.{ext}", zip, name=SHORTREADNAMES, ext=SHORTREADEXTENSIONS)
	output:
		temp(expand(TMPDIR + "{name}.cor.{ext}", zip, name=SHORTREADNAMES, ext=SHORTREADEXTENSIONS))
	params:
		files = lambda wildcards, input: ' '.join(["-r " + name for name in input]),
		alpha = 7.0 / SHORTREADCOVERAGE
	threads: 40
	log:
		stdout = TMPDIR + "lighter_stdout.txt",
		stderr = TMPDIR + "lighter_stderr.txt"
	shell:
		"/usr/bin/time -v {LIGHTERPATH} -od {TMPDIR} -t {threads} -k {SMALLK} {GENOMESIZE} {params.alpha} {params.files} 1> {log.stdout} 2> {log.stderr}"

rule read_names:
	input: rules.correct_short_reads.output
	output: temp("filenames")
	shell: "ls -1 {input} > {output}"

rule run_bcalm:
	input: 
		name = "filenames",
		files = rules.correct_short_reads.output
	output: temp("filenames.unitigs.fa")
	shadow: "full"
	log:
		stdout = TMPDIR + "bcalm_stdout.txt",
		stderr = TMPDIR + "bcalm_stderr.txt"
	threads: 40
	shell: "/usr/bin/time -v {BCALMPATH} -nb-cores {threads} -in {input.name} -kmer-size {BIGK} -abundance-min {ABUNDANCE} > {log.stdout} 2> {log.stderr}"

rule convert_bcalm:
	input: rules.run_bcalm.output
	output: temp(TMPDIR + "graph-tip.gfa")
	shell: "{BCALMCONVERTPATH} {input} {output} {BIGK}"

rule split_graph:
	input: rules.convert_bcalm.output
	output: TMPDIR + "graph.gfa"
	shell:  "{ALIGNERBINDIR}SplitGraph {input} 150 {output}"

rule align_reads:
	input:
		graph = TMPDIR + "graph.gfa",
		reads = expand(LONGREADDIR + "{name}", name=LONGREADS)
	params:
		readconcat = lambda wildcards, input: ' '.join(input.reads)
	output:
		TMPDIR + "alns.gam"
	log:
		stdout = TMPDIR + "aligner_stdout.txt",
		stderr = TMPDIR + "aligner_stderr.txt"
	threads: 40
	shell:
		"/usr/bin/time -v {ALIGNERBINDIR}GraphAligner -g {input.graph} -a {output} -f {params.readconcat} -t {threads} 1> {log.stdout} 2> {log.stderr}"

rule induce_overlaps:
	input:
		graph = TMPDIR + "graph.gfa",
		alignments = rules.align_reads.output
	output:
		overlaps = TMPDIR + "overlaps.tmp"
	threads: 40
	log:
		stdout = TMPDIR + "overlap_stdout.txt",
		stderr = TMPDIR + "overlap_stderr.txt"
	shell:
		"/usr/bin/time -v {ALIGNERBINDIR}InduceOverlaps {input.graph} {input.alignments} {MINOVERLAPLENGTH} {MINOVERLAPIDENTITY} {threads} 250 {output} 1> {log.stdout} 2> {log.stderr}"

rule initial_assembly:
	input:
		graph = TMPDIR + "graph.gfa",
		alignments = rules.align_reads.output,
		overlaps = rules.induce_overlaps.output
	output:
		assembly = TMPDIR + "assembly.gfa",
		translatedreads = TMPDIR + "alns-translated.gam"
	threads: 40
	log:
		stdout = TMPDIR + "assemble_stdout.txt",
		stderr = TMPDIR + "assemble_stderr.txt"
	shell:
		"/usr/bin/time -v {ALIGNERBINDIR}AssembleByAlignment {input.graph} {input.alignments} {input.overlaps} {output.assembly} {output.translatedreads} {MAXOVERLAPCOUNT} 1> {log.stdout} 2> {log.stderr}"

rule unitigify:
	input: TMPDIR + "{graph}.gfa"
	output:
		graph = temp(TMPDIR + "{graph}-unitig.gfa"),
		translation = temp(TMPDIR + "{graph}-unitig-translation.txt")
	shell: "{ALIGNERSCRIPTDIR}unitigify_assembly.py {input} {output.graph} {output.translation}"

rule untip:
	input: TMPDIR + "{graph}.gfa"
	output: temp(TMPDIR + "{graph}-untip.gfa")
	shell: "{ALIGNERBINDIR}UntipRelative 1000 2000 0.01 < {input} > {output}"

rule topofy:
	input: TMPDIR + "{graph}.gfa"
	output: temp(TMPDIR + "{graph}-topo.vg")
	shell: "{ALIGNERSCRIPTDIR}filter_unconnected_nodes.py {input} /dev/stdout | sed 's/[0-9]\\+M/0M/g' | {VGPATH} view -Fv - > {output}"

rule snarls:
	input: TMPDIR + "{graph}-topo.vg"
	output: temp(TMPDIR + "{graph}-traversals.travs")
	shell: "{VGPATH} snarls -r {output} -m 1000 {input} > /dev/null"

rule fix_traversals:
	input: TMPDIR + "{graph}-traversals.travs"
	output: temp(TMPDIR + "{graph}-traversals.json")
	shell: "{VGPATH} view -E {input} | sed 's/$/,/g' | sed '1 s/^/[/g' | sed '$ s/,$/]/g' > {output}"

rule make_chains:
	input:
		graph = TMPDIR + "{graph}.gfa",
		traversals = TMPDIR + "{graph}-traversals.json"
	output:
		graph_withchains = temp(TMPDIR + "{graph}-withchains.gfa"),
		chains = temp(TMPDIR + "{graph}-chains.gfa")
	shell: "{ALIGNERSCRIPTDIR}make_chain_graph.py {input.graph} {input.traversals} {output.graph_withchains} {output.chains}"

rule resolve_small_cycles:
	input: TMPDIR + "{graph}.gfa",
	output: temp(TMPDIR + "{graph}-cycle.gfa")
	shell: "{ALIGNERSCRIPTDIR}resolve_short_repeats.py {input} {output}"

rule translate_1:
	input:
		alns = rules.initial_assembly.output.translatedreads,
		translation = TMPDIR + "assembly-untip-unitig-translation.txt"
	output: temp(TMPDIR + "translated-1.gam")
	shell: "{ALIGNERBINDIR}TranslatePath {input.alns} {input.translation} {output}"

rule resolve_small_tangles:
	input:
		graph = TMPDIR + "assembly-untip-unitig-withchains.gfa",
		alns = TMPDIR + "translated-1.gam"
	output: temp(TMPDIR + "assembly-untip-unitig-repeat.gfa")
	shell: "{ALIGNERBINDIR}ResolveSmallTangles {input.graph} {input.alns} 5000 {output} /dev/null"

rule final:
	input:
		graph_withchains = TMPDIR + "assembly-untip-unitig-repeat-unitig-cycle-unitig-withchains.gfa",
		graph_chains = TMPDIR + "assembly-untip-unitig-repeat-unitig-cycle-unitig-chains.gfa"
	output:
		graph_withchains = OUTDIR + "assembly.gfa",
		graph_chains = OUTDIR + "chains.gfa"
	run:
		shell("cp {input.graph_withchains} {output.graph_withchains}"),
		shell("cp {input.graph_chains} {output.graph_chains}")

rule nodeinfo_assembly:
	input: rules.final.output.graph_withchains
	output: OUTDIR + "nodeinfo_assembly.csv"
	shell: "{ALIGNERSCRIPTDIR}graph_infocsv.py < {input} > {output}"

rule nodeinfo_chains:
	input: rules.final.output.graph_chains
	output: OUTDIR + "nodeinfo_chains.csv"
	shell: "{ALIGNERSCRIPTDIR}graph_infocsv.py < {input} > {output}"
